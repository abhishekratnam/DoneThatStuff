'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function getSvgPath(_ref) {
  var _ref$cornerRadius = _ref.cornerRadius,
      cornerRadius = _ref$cornerRadius === void 0 ? 0 : _ref$cornerRadius,
      topLeftCornerRadius = _ref.topLeftCornerRadius,
      topRightCornerRadius = _ref.topRightCornerRadius,
      bottomRightCornerRadius = _ref.bottomRightCornerRadius,
      bottomLeftCornerRadius = _ref.bottomLeftCornerRadius,
      cornerSmoothing = _ref.cornerSmoothing,
      width = _ref.width,
      height = _ref.height;
  var defaultPathParams = getPathParamsForCorner({
    width: width,
    height: height,
    cornerRadius: cornerRadius,
    cornerSmoothing: cornerSmoothing
  }); // Most of the time, all corners will have the same radius
  // Instead of calculating path params for all 4 corners,
  // we want to use the default path params whenever possible

  var topLeftPathPathParams = topLeftCornerRadius !== undefined ? getPathParamsForCorner({
    width: width,
    height: height,
    cornerRadius: topLeftCornerRadius,
    cornerSmoothing: cornerSmoothing
  }) : defaultPathParams;
  var topRightPathPathParams = topRightCornerRadius !== undefined ? getPathParamsForCorner({
    width: width,
    height: height,
    cornerRadius: topRightCornerRadius,
    cornerSmoothing: cornerSmoothing
  }) : defaultPathParams;
  var bottomRightPathPathParams = bottomRightCornerRadius !== undefined ? getPathParamsForCorner({
    width: width,
    height: height,
    cornerRadius: bottomRightCornerRadius,
    cornerSmoothing: cornerSmoothing
  }) : defaultPathParams;
  var bottomLeftPathPathParams = bottomLeftCornerRadius !== undefined ? getPathParamsForCorner({
    width: width,
    height: height,
    cornerRadius: bottomLeftCornerRadius,
    cornerSmoothing: cornerSmoothing
  }) : defaultPathParams;
  return ("\n    " + drawTopRightPath(topRightPathPathParams) + "\n    " + drawBottomRightPath(bottomRightPathPathParams) + "\n    " + drawBottomLeftPath(bottomLeftPathPathParams) + "\n    " + drawTopLeftPath(topLeftPathPathParams) + "\n  ").replace(/[\t\s\n]+/g, ' ').trim();
}

function drawTopRightPath(_ref2) {
  var cornerRadius = _ref2.cornerRadius,
      width = _ref2.width,
      height = _ref2.height,
      a = _ref2.a,
      b = _ref2.b,
      c = _ref2.c,
      d = _ref2.d,
      p = _ref2.p,
      circularSectionLength = _ref2.circularSectionLength;

  if (cornerRadius) {
    return "\n    M " + Math.max(width / 2, width - p) + " 0\n    C " + (width - (p - a)) + " 0 " + (width - (p - a - b)) + " 0 " + (width - (p - a - b - c)) + " " + d + "\n    a " + cornerRadius + " " + cornerRadius + " 0 0 1 " + circularSectionLength + " " + circularSectionLength + "\n    C " + width + " " + (p - a - b) + "\n        " + width + " " + (p - a) + "\n        " + width + " " + Math.min(height / 2, p);
  } else {
    return "M " + width / 2 + " 0\n    L " + width + " " + 0 + "\n    L " + width + " " + height / 2;
  }
}

function drawBottomRightPath(_ref3) {
  var cornerRadius = _ref3.cornerRadius,
      width = _ref3.width,
      height = _ref3.height,
      a = _ref3.a,
      b = _ref3.b,
      c = _ref3.c,
      d = _ref3.d,
      p = _ref3.p,
      circularSectionLength = _ref3.circularSectionLength;

  if (cornerRadius) {
    return "\n    L " + width + " " + Math.max(height / 2, height - p) + "\n    C " + width + " " + (height - (p - a)) + "\n      " + width + " " + (height - (p - a - b)) + "\n      " + (width - d) + " " + (height - (p - a - b - c)) + "\n    a " + cornerRadius + " " + cornerRadius + " 0 0 1 -" + circularSectionLength + " " + circularSectionLength + "\n    C " + (width - (p - a - b)) + " " + height + "\n      " + (width - (p - a)) + " " + height + "\n      " + Math.max(width / 2, width - p) + " " + height;
  } else {
    return "L " + width + " " + height + "\n    L " + width / 2 + " " + height;
  }
}

function drawBottomLeftPath(_ref4) {
  var cornerRadius = _ref4.cornerRadius,
      width = _ref4.width,
      height = _ref4.height,
      a = _ref4.a,
      b = _ref4.b,
      c = _ref4.c,
      d = _ref4.d,
      p = _ref4.p,
      circularSectionLength = _ref4.circularSectionLength;

  if (cornerRadius) {
    return "\n    L " + Math.min(width / 2, p) + " " + height + "\n    C " + (p - a) + " " + height + "\n      " + (p - a - b) + " " + height + "\n      " + (p - a - b - c) + " " + (height - d) + "\n    a " + cornerRadius + " " + cornerRadius + " 0 0 1 -" + circularSectionLength + " -" + circularSectionLength + "\n    C 0 " + (height - (p - a - b)) + "\n      0 " + (height - (p - a)) + "\n      0 " + Math.max(height / 2, height - p);
  } else {
    return "\n    L " + 0 + " " + height + "\n    L " + 0 + " " + height / 2;
  }
}

function drawTopLeftPath(_ref5) {
  var cornerRadius = _ref5.cornerRadius,
      width = _ref5.width,
      height = _ref5.height,
      a = _ref5.a,
      b = _ref5.b,
      c = _ref5.c,
      d = _ref5.d,
      p = _ref5.p,
      circularSectionLength = _ref5.circularSectionLength;

  if (cornerRadius) {
    return "\n    L 0 " + Math.min(height / 2, p) + "\n    C 0 " + (p - a) + "\n      0 " + (p - a - b) + "\n      " + d + " " + (p - a - b - c) + "\n    a " + cornerRadius + " " + cornerRadius + " 0 0 1 " + circularSectionLength + " -" + circularSectionLength + "\n    C " + (p - a - b) + " 0\n      " + (p - a) + " 0\n      " + +Math.min(width / 2, p) + " 0\n    Z";
  } else {
    return "L " + 0 + " " + 0 + "\n    Z";
  }
}

function getPathParamsForCorner(_ref6) {
  var cornerRadius = _ref6.cornerRadius,
      cornerSmoothing = _ref6.cornerSmoothing,
      width = _ref6.width,
      height = _ref6.height;
  var maxRadius = Math.min(width, height) / 2;
  cornerRadius = Math.min(cornerRadius, maxRadius); // The article from figma's blog
  // https://www.figma.com/blog/desperately-seeking-squircles/
  //
  // The original code
  // https://github.com/MartinRGB/Figma_Squircles_Approximation/blob/bf29714aab58c54329f3ca130ffa16d39a2ff08c/js/rounded-corners.js#L64
  // 12.2 from the article

  var p = Math.min((1 + cornerSmoothing) * cornerRadius, maxRadius);
  var angleAlpha, angleBeta;

  if (cornerRadius <= maxRadius / 2) {
    angleBeta = 90 * (1 - cornerSmoothing);
    angleAlpha = 45 * cornerSmoothing;
  } else {
    // When `cornerRadius` is larger and `maxRadius / 2`,
    // these angles also depend on `cornerRadius` and `maxRadius / 2`
    //
    // I did a few tests in Figma and this code generated similar but not identical results
    // `diffRatio` was called `change_percentage` in the orignal code
    var diffRatio = (cornerRadius - maxRadius / 2) / (maxRadius / 2);
    angleBeta = 90 * (1 - cornerSmoothing * (1 - diffRatio));
    angleAlpha = 45 * cornerSmoothing * (1 - diffRatio);
  }

  var angleTheta = (90 - angleBeta) / 2; // This was called `h_longest` in the original code
  // In the article this is the distance between 2 control points: P3 and P4

  var p3ToP4Distance = cornerRadius * Math.tan(toRadians(angleTheta / 2)); // This was called `l` in the original code

  var circularSectionLength = Math.sin(toRadians(angleBeta / 2)) * cornerRadius * Math.sqrt(2); // a, b, c and d are from 11.1 in the article

  var c = p3ToP4Distance * Math.cos(toRadians(angleAlpha));
  var d = c * Math.tan(toRadians(angleAlpha));
  var b = (p - circularSectionLength - c - d) / 3;
  var a = 2 * b;
  return {
    a: a,
    b: b,
    c: c,
    d: d,
    p: p,
    width: width,
    height: height,
    circularSectionLength: circularSectionLength,
    cornerRadius: cornerRadius
  };
}

function toRadians(degrees) {
  return degrees * Math.PI / 180;
}

exports.getSvgPath = getSvgPath;
//# sourceMappingURL=figma-squircle.cjs.development.js.map
